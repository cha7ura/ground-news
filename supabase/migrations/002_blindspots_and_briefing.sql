-- Ground News Sri Lanka - Blindspots, Daily Briefing, and Original Reporting

-- ============================================
-- ADD BLINDSPOT FIELDS TO STORIES
-- ============================================

-- Blindspot type: which political perspective is missing
ALTER TABLE stories ADD COLUMN IF NOT EXISTS blindspot_type TEXT 
  CHECK (blindspot_type IS NULL OR blindspot_type IN ('left', 'right', 'both', 'none'));

-- Whether this story is a blindspot (has significant coverage gap)
ALTER TABLE stories ADD COLUMN IF NOT EXISTS is_blindspot BOOLEAN DEFAULT false;

-- Blindspot severity: how significant is the coverage gap (0-100)
ALTER TABLE stories ADD COLUMN IF NOT EXISTS blindspot_severity INT DEFAULT 0 
  CHECK (blindspot_severity >= 0 AND blindspot_severity <= 100);

-- ============================================
-- ADD ORIGINAL REPORTING TRACKING
-- ============================================

-- Track if source typically does original reporting vs aggregation
ALTER TABLE sources ADD COLUMN IF NOT EXISTS is_original_reporter BOOLEAN DEFAULT true;

-- Track original reporting percentage for each article
ALTER TABLE articles ADD COLUMN IF NOT EXISTS is_original_reporting BOOLEAN;

-- ============================================
-- ADD READING TIME AND BRIEFING FIELDS
-- ============================================

-- Estimated reading time in minutes for article
ALTER TABLE articles ADD COLUMN IF NOT EXISTS reading_time_minutes INT;

-- Stories for daily briefing selection
ALTER TABLE stories ADD COLUMN IF NOT EXISTS is_briefing_pick BOOLEAN DEFAULT false;
ALTER TABLE stories ADD COLUMN IF NOT EXISTS briefing_date DATE;

-- ============================================
-- DAILY BRIEFING TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS daily_briefings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  briefing_date DATE UNIQUE NOT NULL,
  
  -- Stats
  story_count INT DEFAULT 0,
  article_count INT DEFAULT 0,
  total_reading_time_minutes INT DEFAULT 0,
  original_reporting_percentage INT DEFAULT 0,
  
  -- Featured story
  featured_story_id UUID REFERENCES stories(id) ON DELETE SET NULL,
  
  -- Summary generated by AI
  summary TEXT,
  
  -- Status
  is_published BOOLEAN DEFAULT false,
  published_at TIMESTAMP,
  
  -- Timestamps
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Junction table for briefing stories
CREATE TABLE IF NOT EXISTS briefing_stories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  briefing_id UUID NOT NULL REFERENCES daily_briefings(id) ON DELETE CASCADE,
  story_id UUID NOT NULL REFERENCES stories(id) ON DELETE CASCADE,
  
  -- Order in briefing
  position INT DEFAULT 0,
  
  -- Whether this is the headline/featured story
  is_featured BOOLEAN DEFAULT false,
  
  UNIQUE(briefing_id, story_id)
);

-- ============================================
-- INDEXES
-- ============================================

CREATE INDEX IF NOT EXISTS idx_stories_blindspot ON stories(is_blindspot) WHERE is_blindspot = true;
CREATE INDEX IF NOT EXISTS idx_stories_blindspot_type ON stories(blindspot_type) WHERE blindspot_type IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_stories_briefing ON stories(is_briefing_pick, briefing_date);
CREATE INDEX IF NOT EXISTS idx_briefings_date ON daily_briefings(briefing_date DESC);
CREATE INDEX IF NOT EXISTS idx_briefing_stories_briefing ON briefing_stories(briefing_id);

-- ============================================
-- FUNCTIONS
-- ============================================

-- Function to detect blindspots in a story
CREATE OR REPLACE FUNCTION detect_story_blindspot(p_story_id UUID)
RETURNS TABLE (
  blindspot_type TEXT,
  is_blindspot BOOLEAN,
  blindspot_severity INT
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_left_count INT;
  v_center_count INT;
  v_right_count INT;
  v_total INT;
  v_blindspot_type TEXT;
  v_is_blindspot BOOLEAN;
  v_severity INT;
BEGIN
  -- Count articles by bias category
  SELECT 
    COUNT(*) FILTER (WHERE s.bias_score < -0.3),
    COUNT(*) FILTER (WHERE s.bias_score >= -0.3 AND s.bias_score <= 0.3),
    COUNT(*) FILTER (WHERE s.bias_score > 0.3),
    COUNT(*)
  INTO v_left_count, v_center_count, v_right_count, v_total
  FROM story_articles sa
  JOIN articles a ON sa.article_id = a.id
  JOIN sources s ON a.source_id = s.id
  WHERE sa.story_id = p_story_id;
  
  -- Determine blindspot type
  IF v_total < 3 THEN
    -- Not enough coverage to determine blindspot
    v_blindspot_type := 'none';
    v_is_blindspot := false;
    v_severity := 0;
  ELSIF v_left_count = 0 AND v_right_count > 0 THEN
    v_blindspot_type := 'left';
    v_is_blindspot := true;
    v_severity := LEAST(100, (v_right_count * 100) / v_total);
  ELSIF v_right_count = 0 AND v_left_count > 0 THEN
    v_blindspot_type := 'right';
    v_is_blindspot := true;
    v_severity := LEAST(100, (v_left_count * 100) / v_total);
  ELSIF v_left_count = 0 AND v_right_count = 0 THEN
    v_blindspot_type := 'both';
    v_is_blindspot := false; -- Center-only isn't really a blindspot
    v_severity := 0;
  ELSE
    v_blindspot_type := 'none';
    v_is_blindspot := false;
    v_severity := 0;
  END IF;
  
  -- Update the story
  UPDATE stories
  SET 
    blindspot_type = v_blindspot_type,
    is_blindspot = v_is_blindspot,
    blindspot_severity = v_severity
  WHERE id = p_story_id;
  
  RETURN QUERY SELECT v_blindspot_type, v_is_blindspot, v_severity;
END;
$$;

-- Function to calculate reading time from content
CREATE OR REPLACE FUNCTION calculate_reading_time(content TEXT)
RETURNS INT
LANGUAGE plpgsql
AS $$
DECLARE
  word_count INT;
  words_per_minute INT := 200; -- Average reading speed
BEGIN
  IF content IS NULL OR content = '' THEN
    RETURN 1;
  END IF;
  
  -- Count words (split by whitespace)
  word_count := array_length(regexp_split_to_array(content, '\s+'), 1);
  
  -- Calculate minutes, minimum 1
  RETURN GREATEST(1, CEIL(word_count::FLOAT / words_per_minute));
END;
$$;

-- Trigger to auto-calculate reading time on article insert/update
CREATE OR REPLACE FUNCTION update_article_reading_time()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.content IS NOT NULL AND (OLD IS NULL OR OLD.content IS DISTINCT FROM NEW.content) THEN
    NEW.reading_time_minutes := calculate_reading_time(NEW.content);
  END IF;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_update_reading_time ON articles;
CREATE TRIGGER trg_update_reading_time
BEFORE INSERT OR UPDATE ON articles
FOR EACH ROW
EXECUTE FUNCTION update_article_reading_time();

-- Function to get blindspot stories
CREATE OR REPLACE FUNCTION get_blindspot_stories(
  p_limit INT DEFAULT 10,
  p_blindspot_type TEXT DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  title TEXT,
  summary TEXT,
  blindspot_type TEXT,
  blindspot_severity INT,
  bias_distribution JSONB,
  source_count INT,
  article_count INT,
  last_updated_at TIMESTAMP
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    s.id,
    s.title,
    s.summary,
    s.blindspot_type,
    s.blindspot_severity,
    s.bias_distribution,
    s.source_count,
    s.article_count,
    s.last_updated_at
  FROM stories s
  WHERE s.is_blindspot = true
    AND s.is_active = true
    AND (p_blindspot_type IS NULL OR s.blindspot_type = p_blindspot_type)
  ORDER BY s.last_updated_at DESC
  LIMIT p_limit;
END;
$$;

-- Function to generate daily briefing
CREATE OR REPLACE FUNCTION generate_daily_briefing(p_date DATE DEFAULT CURRENT_DATE)
RETURNS UUID
LANGUAGE plpgsql
AS $$
DECLARE
  v_briefing_id UUID;
  v_story_count INT;
  v_article_count INT;
  v_reading_time INT;
  v_original_pct INT;
  v_featured_id UUID;
BEGIN
  -- Check if briefing already exists
  SELECT id INTO v_briefing_id FROM daily_briefings WHERE briefing_date = p_date;
  
  IF v_briefing_id IS NOT NULL THEN
    -- Delete existing briefing stories to regenerate
    DELETE FROM briefing_stories WHERE briefing_id = v_briefing_id;
  ELSE
    -- Create new briefing
    INSERT INTO daily_briefings (briefing_date)
    VALUES (p_date)
    RETURNING id INTO v_briefing_id;
  END IF;
  
  -- Select top stories for briefing (most sources, most recent)
  INSERT INTO briefing_stories (briefing_id, story_id, position, is_featured)
  SELECT 
    v_briefing_id,
    s.id,
    ROW_NUMBER() OVER (ORDER BY s.source_count DESC, s.last_updated_at DESC),
    ROW_NUMBER() OVER (ORDER BY s.source_count DESC, s.last_updated_at DESC) = 1
  FROM stories s
  WHERE s.is_active = true
    AND s.last_updated_at >= p_date - INTERVAL '24 hours'
    AND s.source_count >= 2
  ORDER BY s.source_count DESC, s.last_updated_at DESC
  LIMIT 10;
  
  -- Get featured story
  SELECT story_id INTO v_featured_id 
  FROM briefing_stories 
  WHERE briefing_id = v_briefing_id AND is_featured = true;
  
  -- Calculate stats
  SELECT 
    COUNT(DISTINCT bs.story_id),
    COUNT(DISTINCT a.id),
    COALESCE(SUM(a.reading_time_minutes), 0),
    COALESCE(
      (COUNT(*) FILTER (WHERE a.is_original_reporting = true) * 100) / NULLIF(COUNT(*), 0),
      0
    )
  INTO v_story_count, v_article_count, v_reading_time, v_original_pct
  FROM briefing_stories bs
  JOIN story_articles sa ON bs.story_id = sa.story_id
  JOIN articles a ON sa.article_id = a.id
  WHERE bs.briefing_id = v_briefing_id;
  
  -- Update briefing stats
  UPDATE daily_briefings
  SET
    story_count = v_story_count,
    article_count = v_article_count,
    total_reading_time_minutes = v_reading_time,
    original_reporting_percentage = v_original_pct,
    featured_story_id = v_featured_id,
    updated_at = NOW()
  WHERE id = v_briefing_id;
  
  RETURN v_briefing_id;
END;
$$;
